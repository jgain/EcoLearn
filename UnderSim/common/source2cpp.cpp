
#include <common/debug_unordered_map.h>
#include <common/debug_string.h>
#include <utility>
#include <stdexcept>

static const uts::unordered_map<uts::string, uts::string> g_sources{

    std::pair<uts::string, uts::string>("basic.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "uniform sampler2D normalMap;\n"
        "uniform sampler2D htMap;\n"
        "\n"
        "uniform int drawWalls; // if 0, draw terrain, else drawing walls\n"
        "uniform vec3 normalWall; // if drawing wall vertices, use this normal\n"
        "\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec3 pos;\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "\n"
        "    // lookup normal in texture\n"
        "    if (drawWalls == 0) // drawing ht field - lookup normals\n"
        "    {\n"
        "        inNormal = texture(normalMap, UV).xyz;\n"
        "        // correct vertex position from heigt map...\n"
        "        v.y = texture(htMap, UV).r;\n"
        "\n"
        "    }\n"
        "    else\n"
        "    {\n"
        "        inNormal = normalWall; // use fixed normal for all wall vertices\n"
        "        if (UV.s < 0.0) // base of wall: leave at z=0.0\n"
        "            v.y = 0.0;\n"
        "        else\n"
        "            v.y = texture(htMap, UV).r;\n"
        "\n"
        "    }\n"
        "\n"
        "    pos = v;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("basic.frag",
        "#version 150\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform int useRegionTexture;\n"
        "uniform int drawContours;\n"
        "\n"
        "uniform sampler2D overlayTexture;\n"
        "\n"
        "in vec3 pos;\n"
        "in vec2 texCoord;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "out vec4 color;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    vec4 Diff;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    // use textur emap for diffuse colour if terrain overlay is present\n"
        "\n"
        "    Diff = (useRegionTexture == 1 ? texture(overlayTexture, texCoord) : diffuse);\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = dot(n, normalize(lightDir));\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (Diff * NdotL + ambient);\n"
        "        color += Diff * NdotL;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV), 0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "        }\n"
        "\n"
        "    // draw contours\n"
        "\n"
        "    if (drawContours == 1)\n"
        "    {\n"
        "        float f  = abs(fract (pos.y*70) - 0.5);\n"
        "        float df = fwidth(pos.y*70);\n"
        "        float g = smoothstep(-1.0*df, 1.0*df , f);\n"
        "\n"
        "        float c = g;\n"
        "        color = vec4(c,c,c,1.0) * color + (1-c)*vec4(1.0,0.0,0.0,1.0);\n"
        "    }\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("genNormal.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: genNormals\n"
        "layout (location=0) in vec2 vertex;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    gl_Position = vec4(vertex.x, vertex.y, 0.0, 1.0); // already in clip space for ortho cam\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("genNormal.frag",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// fragment shader: gennormal\n"
        "out vec4 norm;\n"
        "\n"
        "uniform vec2 imgSize;\n"
        "uniform sampler2D htMap;\n"
        "\n"
        "uniform vec2 scale;\n"
        "\n"
        "// NB!!! y and z have been swapped: y is now height above (x,z) base plane.\n"
        "// F = (x, f(x,z), z); need dF/dx and dF/dz to define base vectors for cross product\n"
        "// dF/dx = (1, df/dx,0); dF/dz = (0, df/dz, 1)\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec2  pos, delta;\n"
        "\n"
        "    // const float scale = 10.0*1024.0; // should be passed as parameter\n"
        "\n"
        "    vec3 dfdx = vec3(1.0, 0.0, 0.0), // df/dx and df/dy used to define normal\n"
        "         dfdy = vec3(0.0, 0.0, 1.0); // y component filled in below\n"
        "\n"
        "    delta.x = 1.0f/imgSize.x;\n"
        "    delta.y = 1.0f/imgSize.y;\n"
        "\n"
        "    pos = (gl_FragCoord.xy + 0.5 ) / imgSize.xy;\n"
        "\n"
        "    dfdx.y = (texture(htMap, vec2(pos.x+delta.x, pos.y)).r/scale.x -\n"
        "              texture(htMap, vec2(pos.x-delta.x, pos.y) ).r/scale.x)/(2.0*delta.x);\n"
        "    dfdy.y = (texture(htMap, vec2(pos.x, pos.y+delta.y) ).r/scale.y -\n"
        "              texture(htMap, vec2(pos.x, pos.y-delta.y) ).r/scale.y)/(2.0*delta.y);\n"
        "\n"
        "\n"
        "    /*\n"
        "\n"
        "    pos = gl_FragCoord.xy;\n"
        "\n"
        "    ivec2 p = ivec2(pos);\n"
        "\n"
        "    dfdx.z = (texelFetch(htMap, ivec2(p.x+1, p.y), 0 ).r -\n"
        "              texelFetch(htMap, ivec2(p.x-1, p.y), 0 ).r)/(0.004);\n"
        "    dfdy.z = (texelFetch(htMap, ivec2(p.x, p.y+1), 0 ).r -\n"
        "              texelFetch(htMap, ivec2(p.x, p.y-1), 0 ).r)/(0.004);\n"
        "    */\n"
        "\n"
        "    vec3 n = -cross(dfdx, dfdy);\n"
        "\n"
        "//  n = vec3(0.0, 1.0, 0.0);\n"
        "    norm = vec4(normalize(n), 0.0);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("simple.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "layout (location=0) in vec4 vertex;\n"
        "\n"
        "void main( void )\n"
        "{\n"
        "    gl_Position = vertex;\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("simple.frag",
        "#version 150\n"
        "\n"
        "//layout(location = 0, index = 0)\n"
        "out vec4 fragColor;\n"
        "\n"
        "void main( void )\n"
        "{\n"
        "    fragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phong.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "layout (location=2) in vec3 vertexNormal;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "// per pixel values to be computed in fragment shader\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "    inNormal = vertexNormal;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phong.frag",
        "#version 150\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "out vec4 color;\n"
        "\n"
        "// NOTE: this shader does not compute a disance attentuation term for lighting.\n"
        "// some more variables need to be passed in for that.\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = max(dot(n, normalize(lightDir)), 0.0);\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (diffuse * NdotL + ambient);\n"
        "        color += diffuse * NdotL; // + ambient;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV),0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "        }\n"
        "\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRS.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "layout (location=2) in vec3 vertexNormal;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "// per pixel values to be computed in fragment shader\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "    inNormal = vertexNormal;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRS.frag",
        "#version 150\n"
        "\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform sampler2D decalTexture;\n"
        "uniform int useTexturing;\n"
        "\n"
        "layout (location = 0) out vec4 grad;\n"
        "layout (location = 1) out vec4 norm;\n"
        "layout (location = 2) out vec4 color;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "// NOTE: this shader does not compute a disance attentuation term for lighting.\n"
        "// some more variables need to be passed in for that.\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = max(dot(n, normalize(lightDir)), 0.0);\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (diffuse * NdotL + ambient);\n"
        "        color += diffuse * NdotL; // + ambient;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV),0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "\n"
        "     }\n"
        "     // decal texturing:\n"
        "     if (useTexturing == 1)\n"
        "     {\n"
        "        vec4 texel = texture(decalTexture, texCoord);\n"
        "        // color = vec4(texCoord.x, texCoord.y, 0.0, 1.0);\n"
        "        // color = vec4(texel.r, texel.g, texel.b, color.a); // GL_REPLACE\n"
        "        color = vec4(mix(color.rgb, texel.rgb, texel.a), color.a); // GL_DECAL\n"
        "     }\n"
        "     norm = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRSmanip.vert",
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader: basicShader; simple Phong Model lighting\n"
        "\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "layout (location=2) in vec3 vertexNormal;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 matDiffuse;\n"
        "uniform vec4 matAmbient;\n"
        "uniform vec4 lightpos; // in camera space\n"
        "uniform vec4 diffuseCol;\n"
        "uniform vec4 ambientCol;\n"
        "\n"
        "// per pixel values to be computed in fragment shader\n"
        "out vec3 normal; // vertex normal\n"
        "out vec3 lightDir; // toLight\n"
        "out vec3 halfVector;\n"
        "out vec4 diffuse;\n"
        "out vec4 ambient;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "    inNormal = vertexNormal;\n"
        "\n"
        "    // map to camera space for lighting etc\n"
        "    normal = normalize(normMx * inNormal);\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "    lightDir  = normalize(lightpos.xyz - ecPos.xyz);\n"
        "    halfVector = normalize(normalize(-ecPos.xyz) + lightDir);\n"
        "\n"
        "    diffuse = matDiffuse * diffuseCol;\n"
        "    ambient = matAmbient * ambientCol;\n"
        "\n"
        "    gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("phongRSmanip.frag",
        "#version 150\n"
        "\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "uniform vec4 specularCol;\n"
        "uniform float shiny;\n"
        "uniform vec4 matSpec;\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform sampler2D decalTexture;\n"
        "uniform int useTexturing;\n"
        "\n"
        "uniform float manipAlpha;\n"
        "\n"
        "layout (location = 0) out vec4 color;\n"
        "\n"
        "in vec3 normal;\n"
        "in vec3 halfVector;\n"
        "in vec3 lightDir;\n"
        "in vec4 diffuse;\n"
        "in vec4 ambient;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "// NOTE: this shader does not compute a disance attentuation term for lighting.\n"
        "// some more variables need to be passed in for that.\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "\n"
        "    vec3 n, halfV,viewV,ldir;\n"
        "    float NdotL,NdotHV;\n"
        "    color = ambient; //global ambient\n"
        "    //float att;\n"
        "\n"
        "    n = normalize(normal);\n"
        "\n"
        "    //compute the dot product between normal and normalized lightdir\n"
        "\n"
        "    NdotL = max(dot(n, normalize(lightDir)), 0.0);\n"
        "\n"
        "    if (NdotL > 0.0) {\n"
        "\n"
        "        //att = 1.0 / (gl_LightSource[0].constantAttenuation +\n"
        "        //    gl_LightSource[0].linearAttenuation * dist +\n"
        "        //    gl_LightSource[0].quadraticAttenuation * dist * dist);\n"
        "        //color += att * (diffuse * NdotL + ambient);\n"
        "        color += diffuse * NdotL; // + ambient;\n"
        "\n"
        "        halfV = normalize(halfVector);\n"
        "        NdotHV = max(dot(n,halfV),0.0);\n"
        "        //color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular *\n"
        "        //pow(NdotHV,gl_FrontMaterial.shininess);\n"
        "        color += matSpec * specularCol * pow(NdotHV, shiny);\n"
        "\n"
        "     }\n"
        "     // decal texturing:\n"
        "     if (useTexturing == 1)\n"
        "     {\n"
        "        vec4 texel = texture(decalTexture, texCoord);\n"
        "        // color = vec4(texCoord.x, texCoord.y, 0.0, 1.0);\n"
        "        // color = vec4(texel.r, texel.g, texel.b, color.a); // GL_REPLACE\n"
        "        color = vec4(mix(color.rgb, texel.rgb, texel.a), color.a); // GL_DECAL\n"
        "     }\n"
        "\n"
        "     color.a = manipAlpha; // override this for all produced fragments\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass1.vert",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "\n"
        "//#version 120\n"
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// vertex shader data: positions and texture coords only\n"
        "layout (location=0) in vec3 vertex;\n"
        "layout (location=1) in vec2 UV;\n"
        "\n"
        "// transformations\n"
        "uniform mat4 MV; // model-view mx\n"
        "uniform mat4 MVproj; //model-view-projection mx\n"
        "uniform mat3 normMx; // normal matrix\n"
        "\n"
        "//colours and material\n"
        "uniform vec4 surfColour;\n"
        "uniform vec4 ptLightPos1; // for side wall lighting\n"
        "uniform vec4 ptLightPos2;\n"
        "\n"
        "// textures with height and precomputed normals\n"
        "uniform sampler2D normalMap;\n"
        "uniform sampler2D htMap;\n"
        "\n"
        "uniform int drawWalls; // if 0, draw terrain, else drawing walls\n"
        "uniform vec3 normalWall; // if drawing wall vertices, use this normal\n"
        "\n"
        "uniform float terrainBase; // lowest point on terrain\n"
        "uniform float terrainBasePad; // additional height padding to avoid 'thin' terrains\n"
        "\n"
        "//varying vec3  normal;\n"
        "//varying vec3  view;\n"
        "//varying float depth;\n"
        "\n"
        "// need for radiance scaling computations in FS\n"
        "// these wil be interpolated per frag and used\n"
        "// during render to FBO\n"
        "\n"
        "out vec3 normal;\n"
        "out float depth;\n"
        "out vec3 view;\n"
        "out vec4 colour;\n"
        "out vec3 lightDir1; // for side wall lighting\n"
        "out vec3 lightDir2;\n"
        "out vec3 halfVector1;\n"
        "out vec3 halfVector2;\n"
        "\n"
        "// needed for contours\n"
        "out vec3 pos;\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main() {\n"
        "    vec3 inNormal, v;\n"
        "\n"
        "    texCoord = UV;\n"
        "    v = vertex;\n"
        "\n"
        "    // lookup normal in texture\n"
        "    if (drawWalls == 0) // drawing ht field - lookup normals\n"
        "    {\n"
        "        inNormal = texture(normalMap, UV).xyz;\n"
        "        // correct vertex position from heigt map...\n"
        "        v.y = texture(htMap, UV).r;\n"
        "    }\n"
        "    else\n"
        "    {\n"
        "        inNormal = normalWall; // use fixed normal for all wall vertices\n"
        "        if (UV.s < 0.0) // base of wall: must adapt to editing\n"
        "            v.y = terrainBase - terrainBasePad;\n"
        "        else\n"
        "            v.y = texture(htMap, UV).r;\n"
        "    }\n"
        "\n"
        "    pos = v;\n"
        "\n"
        "    // vertex in camera coords\n"
        "    vec4 ecPos = MV * vec4(v, 1.0);\n"
        "\n"
        "//  view   = -(gl_ModelViewMatrix*gl_Vertex).xyz;\n"
        "//  normal = gl_NormalMatrix*gl_Normal;\n"
        "//  depth  = log(-(gl_ModelViewMatrix*gl_Vertex).z);\n"
        "\n"
        "  view   = -ecPos.xyz;\n"
        "  //normal = normalize(inNormal);\n"
        "  normal = normalize(normMx * inNormal);\n"
        "  depth  = log(-ecPos.z);\n"
        "\n"
        "  lightDir1  = normalize(ptLightPos1.xyz - ecPos.xyz);\n"
        "  lightDir2  = normalize(ptLightPos2.xyz - ecPos.xyz);\n"
        "  halfVector1 = normalize(normalize(-ecPos.xyz) + lightDir1);\n"
        "  halfVector2 = normalize(normalize(-ecPos.xyz) + lightDir1);\n"
        "\n"
        "  gl_Position = MVproj * vec4(v, 1.0); // clip space position\n"
        "\n"
        "  colour = surfColour;\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass1.frag",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "\n"
        "//#version 120\n"
        "//#extension GL_ARB_draw_buffers : enable\n"
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "uniform int drawWalls;\n"
        "uniform int drawContours;\n"
        "uniform int drawGridLines;\n"
        "uniform int drawWallContours;\n"
        "uniform int drawWallGridLines;\n"
        "\n"
        "uniform int useRegionTexture;\n"
        "uniform int useConstraintTexture;\n"
        "\n"
        "uniform int drawOutOfBounds;\n"
        "uniform float outBoundsMax;\n"
        "uniform float outBoundsMin;\n"
        "uniform float outBoundsBlend;\n"
        "uniform vec4 outBoundsCol;\n"
        "\n"
        "uniform sampler2D overlayTexture;\n"
        "uniform sampler2D constraintTexture;\n"
        "\n"
        "in vec3 lightDir1; // for side wall lighting\n"
        "in vec3 lightDir2;\n"
        "in vec3 halfVector1;\n"
        "in vec3 halfVector2;\n"
        "\n"
        "in vec3  normal;\n"
        "in vec3  view;\n"
        "in float depth;\n"
        "in vec4 colour;\n"
        "\n"
        "in vec3 pos;\n"
        "in vec2 texCoord;\n"
        "\n"
        "layout (location = 0) out vec4 grad;\n"
        "layout (location = 1) out vec4 norm;\n"
        "layout (location = 2) out vec4 col;\n"
        "\n"
        "// contour and grid line params\n"
        "uniform float gridColFactor;\n"
        "uniform float gridX;\n"
        "uniform float gridZ;\n"
        "uniform float gridThickness;\n"
        "uniform float contourSep;\n"
        "uniform float contourThickness;\n"
        "uniform float contourColFactor;\n"
        "\n"
        "void main(void) {\n"
        "  const float eps = 0.01;\n"
        "  const float foreshortening = 0.4;\n"
        "\n"
        "  vec3 n = normalize(normal);\n"
        "\n"
        "  float gs  = n.z<eps ? 1.0/eps : 1.0/n.z;\n"
        "\n"
        "  gs = pow(gs,foreshortening);\n"
        "\n"
        "  float gx  = -n.x*gs;\n"
        "  float gy  = -n.y*gs;\n"
        "\n"
        "  grad = vec4(gx,gy,depth,1.0);\n"
        "  norm = vec4(n,gl_FragCoord.z);\n"
        "\n"
        "  // do nota pply radiance scaling to walls\n"
        "  if (drawWalls == 1)\n"
        "     norm = vec4(0.0,0.0,0.0,gl_FragCoord.z);\n"
        "\n"
        "  // use texture map for colour if terrain overlay is present\n"
        "\n"
        "  col = (useRegionTexture == 1 ? texture(overlayTexture, texCoord) : colour);\n"
        "\n"
        "  // blend in constraint texture if present:\n"
        "  if (useConstraintTexture == 1)\n"
        "  {\n"
        "      vec4 texel = texture(constraintTexture, texCoord);\n"
        "      col = vec4(mix(col.rgb, texel.rgb, texel.a), col.a);\n"
        "  }\n"
        "\n"
        "  if (drawWalls == 1) // compute ambient + diffuse term 2 opposite point lights\n"
        "  {\n"
        "      col = vec4(colour * ( clamp(dot(n, normalize(lightDir1) ), 0.0,1.0) +\n"
        "                            clamp(dot(n, normalize(lightDir2) ), 0.0,1.0) + 0.3) );\n"
        "  }\n"
        "\n"
        " // draw contours - always draw terrain contours if set, but do not necessarily draw side wall contours\n"
        "\n"
        "  if (drawContours == 1 && (drawWalls == 0 || (drawWallContours == 1 && drawWalls == 1)) )\n"
        "    {\n"
        "        float f  = abs(fract (pos.y*contourSep) - 0.5);\n"
        "        float df = fwidth(pos.y*contourSep);\n"
        "        float g = smoothstep(contourThickness*df, 2.0*contourThickness*df , f);\n"
        "\n"
        "        float c = g;\n"
        "        //col = vec4(c,c,c,1.0) * col + (1-c)*vec4(1.0,0.0,0.0,1.0);\n"
        "        col = vec4(c,c,c,1.0)*col + (1-c)*contourColFactor*col;\n"
        "    }\n"
        "\n"
        "   // draw grid lines, but not on walls\n"
        "   if (drawGridLines == 1 && (drawWalls == 0 || (drawWalls == 1 && drawWallGridLines == 1)) )\n"
        "   {\n"
        "        vec2 f  = abs(fract (vec2(pos.x*gridX, pos.z*gridZ)) - 0.5);\n"
        "        vec2 df = fwidth(vec2(pos.x*gridX, pos.z*gridZ));\n"
        "        vec2 g = smoothstep(gridThickness*df, 2.0*gridThickness*df , f);\n"
        "        float c = g.x * g.y;\n"
        "        col = vec4(c,c,c,1.0)*col + (1-c)*gridColFactor*col;\n"
        "   }\n"
        "\n"
        "   // add in out of bounds colour indication\n"
        "   if (drawOutOfBounds == 1 && drawWalls == 0 && (pos.y > outBoundsMax || pos.y < outBoundsMin) )\n"
        "       col = mix(col, outBoundsCol, outBoundsBlend);\n"
        "\n"
        "   col = clamp(col, 0.0, 1.0);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass2.vert",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "#version 150\n"
        "#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "// pass through vertex shader: screen aligned quad\n"
        "// vertex shader data: positions coords only\n"
        "\n"
        "layout (location=0) in vec2 vertex;\n"
        "layout (location=1) in vec2 tcoord;\n"
        "\n"
        "out vec2 texCoord;\n"
        "\n"
        "void main(void) {\n"
        "  texCoord = tcoord;\n"
        "  gl_Position = vec4(vertex.x, vertex.y, 0.0, 1.0); //clip space position - already in clip space\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("rad_scaling_pass2.frag",
        "/****************************************************************************\n"
        "* Render Radiance Scaling                                                   *\n"
        "* Meshlab's plugin                                                          *\n"
        "*                                                                           *\n"
        "* Copyright(C) 2010                                                         *\n"
        "* Vergne Romain, Dumas Olivier                                              *\n"
        "* INRIA - Institut Nationnal de Recherche en Informatique et Automatique    *\n"
        "*                                                                           *\n"
        "* All rights reserved.                                                      *\n"
        "*                                                                           *\n"
        "* This program is free software; you can redistribute it and/or modify      *\n"
        "* it under the terms of the GNU General Public License as published by      *\n"
        "* the Free Software Foundation; either version 2 of the License, or         *\n"
        "* (at your option) any later version.                                       *\n"
        "*                                                                           *\n"
        "* This program is distributed in the hope that it will be useful,           *\n"
        "* but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n"
        "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n"
        "* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *\n"
        "* for more details.                                                         *\n"
        "*                                                                           *\n"
        "*****************************************************************************\n"
        "* Modified by P Marais, 2014                                                *\n"
        "*****************************************************************************/\n"
        "//#version 120\n"
        "//#extension GL_EXT_gpu_shader4 : enable\n"
        "#version 150\n"
        "//#extension GL_ARB_explicit_attrib_location: enable\n"
        "\n"
        "out vec4 fcolour;\n"
        "\n"
        "in vec2 texCoord;\n"
        "\n"
        "uniform vec2 imgSize;  // used to find frag coordinates for screen aligned quad\n"
        "uniform vec4 lightPos0; // in camera coordinates\n"
        "uniform vec4 lightPos1; // in camera coordinates\n"
        "\n"
        "uniform sampler2D grad;  // (gx,gy,depth,1.0)\n"
        "uniform sampler2D norm;  // (nx,ny,nz,depth)\n"
        "uniform sampler2D colormap; // (r,g,b,1.0)\n"
        "\n"
        "uniform sampler2D manipTTexture; // texture with all manipulator fragments\n"
        "\n"
        "uniform float     sw;\n"
        "uniform float     sh;\n"
        "uniform float     enhancement;\n"
        "uniform float     transition;\n"
        "uniform bool      enabled;\n"
        "uniform bool      invert;\n"
        "uniform int       display;\n"
        "uniform bool      twoLS;\n"
        "uniform sampler2D convexLS;\n"
        "uniform sampler2D concavLS;\n"
        "\n"
        "\n"
        "// **** GRADIENT DATA ****\n"
        "// |A|B|C|\n"
        "// |D|X|E|\n"
        "// |F|G|H|\n"
        "vec4 X,A,B,C,D,E,F,G,H;\n"
        "\n"
        "// **** UTIL FUNCTIONS ****\n"
        "void loadValues() {\n"
        "\n"
        "  //vec2 texCoord = (gl_FragCoord.xy + 0.5 ) / imgSize.xy;\n"
        "\n"
        "  float xc = texCoord.s;\n"
        "  float xm = texCoord.s-sw;\n"
        "  float xp = texCoord.s+sw;\n"
        "\n"
        "  float yc = texCoord.t;\n"
        "  float ym = texCoord.t-sh;\n"
        "  float yp = texCoord.t+sh;\n"
        "\n"
        "  X = texture(grad,vec2(xc,yc));\n"
        "  A = texture(grad,vec2(xm,yp));\n"
        "  B = texture(grad,vec2(xc,yp));\n"
        "  C = texture(grad,vec2(xp,yp));\n"
        "  D = texture(grad,vec2(xm,yc));\n"
        "  E = texture(grad,vec2(xp,yc));\n"
        "  F = texture(grad,vec2(xm,ym));\n"
        "  G = texture(grad,vec2(xc,ym));\n"
        "  H = texture(grad,vec2(xp,ym));\n"
        "}\n"
        "\n"
        "vec3 hsvToRgb(in float h,in float s,in float v) {\n"
        "  vec3 color;\n"
        "  int hi = int(floor(h/60.0))%6;\n"
        "  float f = h/60.0 - floor(h/60.0);\n"
        "  float p = v*(1.0-s);\n"
        "  float q = v*(1.0-f*s);\n"
        "  float t = v*(1.0-(1.0-f)*s);\n"
        "\n"
        "  if(hi==0) color = vec3(v,t,p);\n"
        "  else if(hi==1) color = vec3(q,v,p);\n"
        "  else if(hi==2) color = vec3(p,v,t);\n"
        "  else if(hi==3) color = vec3(p,q,v);\n"
        "  else if(hi==4) color = vec3(t,p,v);\n"
        "  else color = vec3(v,p,q);\n"
        "\n"
        "  return color;\n"
        "}\n"
        "\n"
        "float tanh(in float c, in float en) {\n"
        "  float cmax = en*15.0;\n"
        "  const float tanhmax = 3.11622;\n"
        "\n"
        "  float x = ((c*cmax*1.0)/tanhmax);\n"
        "  float e = exp(-2.0*x);\n"
        "  float t = clamp((1.0-e)/(1.0+e),-1.0,1.0);\n"
        "\n"
        "  return t;\n"
        "}\n"
        "\n"
        "// **** WARPING FUNCTION ****\n"
        "float warp(in float impfunc,in float beta) {\n"
        "  const float alpha = 0.1;\n"
        "  float expbeta = exp(-beta);\n"
        "  return (alpha*expbeta+impfunc*(1.0-alpha-alpha*expbeta)) / (alpha+impfunc*(expbeta-alpha-alpha*expbeta));\n"
        "}\n"
        "\n"
        "// **** WEIGHT FUNCTIONS ****\n"
        "float silhouetteWeight(in float s) {\n"
        "  const float ts = 0.07;\n"
        "  const float t2 = 0.9+ts;\n"
        "  const float t1 = t2-0.01;\n"
        "\n"
        "  return smoothstep(t1,t2,max(1.0-s,0.9));\n"
        "}\n"
        "\n"
        "float weight() {\n"
        "  return (silhouetteWeight(abs(A.z-X.z)) +\n"
        "      silhouetteWeight(abs(B.z-X.z)) +\n"
        "       silhouetteWeight(abs(C.z-X.z)) +\n"
        "       silhouetteWeight(abs(D.z-X.z)) +\n"
        "       silhouetteWeight(abs(E.z-X.z)) +\n"
        "       silhouetteWeight(abs(F.z-X.z)) +\n"
        "       silhouetteWeight(abs(G.z-X.z)) +\n"
        "       silhouetteWeight(abs(H.z-X.z)))/8.0;\n"
        "}\n"
        "\n"
        "// **** CURVATURE FUNCTIONS ****\n"
        "vec3 hessian() {\n"
        "  float xx = E.x-D.x;\n"
        "  float xy = E.y-D.y;\n"
        "  float yx = B.x-G.x;\n"
        "  float yy = B.y-G.y;\n"
        "\n"
        "  return vec3(xx,yy,(xy+yx)/2.0);\n"
        "}\n"
        "\n"
        "float curvature(in float w, in vec3 h, in float e) {\n"
        "  float c = tanh(-(h.x+h.y)/2.0,e);\n"
        "  return invert ? -c*max(w-0.5,0.0) : c*max(w-0.5,0.0);\n"
        "}\n"
        "\n"
        "// **** DESCRIPTOR FUNCTIONS ****\n"
        "vec4 coloredDescriptor(in float c, in float s) {\n"
        "  vec3 rgb;\n"
        "  vec3 convMax = vec3(0.1,0.1,0.8);\n"
        "  vec3 convMin = vec3(0.2,0.2,0.6);\n"
        "  vec3 concMax = vec3(0.8,0.1,0.1);\n"
        "  vec3 concMin = vec3(0.6,0.2,0.2);\n"
        "  vec3 plane   = vec3(0.7,0.7,0.2);\n"
        "  float t = 0.02;\n"
        "  float a;\n"
        "\n"
        "  if(c<-t) {\n"
        "    a = (-c-t)/(1.0-t);\n"
        "    rgb = mix(concMin,concMax,a);\n"
        "  } else if(c>t) {\n"
        "    a = (c-t)/(1.0-t);\n"
        "    rgb = mix(convMin,convMax,a);\n"
        "  } else if(c<0.0) {\n"
        "    a = -c/t;\n"
        "    rgb = mix(plane,concMin,a);\n"
        "  } else {\n"
        "    a = c/t;\n"
        "    rgb = mix(plane,convMin,a);\n"
        "  }\n"
        "\n"
        "  if(s<1.0)\n"
        "    rgb = vec3(0.2);\n"
        "\n"
        "  return vec4(rgb,1.0);\n"
        "}\n"
        "\n"
        "vec4 greyDescriptor(in float c, in float s) {\n"
        "  return vec4((c*0.5+0.5)-(1.0-s));\n"
        "}\n"
        "\n"
        "// **** LIT SPHERE FUNCTIONS ****\n"
        "vec4 oneLitSphere(in vec3 n,in float c) {\n"
        "  vec4 color = texture(convexLS,(n.xy*0.5)+vec2(0.5));\n"
        "\n"
        "  return enabled ? color*warp(length(color),c) : color;\n"
        "}\n"
        "\n"
        "vec4 twoLitSphere(in vec3 n,in float w,in vec3 h,in float c) {\n"
        "  const float eps = 0.2;\n"
        "\n"
        "  vec2 coord = (n.xy*0.5)+vec2(0.5);\n"
        "  vec4 cconv = texture(convexLS,coord);\n"
        "  vec4 cconc = texture(concavLS,coord);\n"
        "  vec4 color = mix(cconc,cconv,smoothstep(0.5-eps,0.5+eps,curvature(w,h,transition)*0.5+0.5));\n"
        "\n"
        "  return enabled ? color*warp(length(color),c) : color;\n"
        "}\n"
        "\n"
        "// **** LIGHTING COMPUTATION ****\n"
        "void main(void) {\n"
        "\n"
        "   //vec2 texCoord = (gl_FragCoord.xy + 0.5 ) / imgSize.xy;\n"
        "\n"
        "  vec3 n = texture(norm, texCoord.st).xyz;\n"
        "\n"
        "  if(n==vec3(0.0)) { // fragments outside mesh or that we do not want affected by RS\n"
        "    fcolour = vec4(texture(colormap, texCoord.st).xyz,1.0);\n"
        "\n"
        "    return;\n"
        "  }\n"
        "\n"
        "  // data\n"
        "  loadValues();\n"
        "  float w = weight();\n"
        "  vec3  h = hessian();\n"
        "  float c = curvature(w,h,enhancement);\n"
        "\n"
        "// Q? this assumes a directional light?\n"
        "  vec3  l0 = normalize(lightPos0.xyz);\n"
        "  vec3  l1 = normalize(lightPos1.xyz);\n"
        "  vec4  m = vec4(texture(colormap, texCoord.st).xyz,1.0);\n"
        "\n"
        "  //Initialize the depth of the fragment with the just saved depth\n"
        "  gl_FragDepth = texture(norm, texCoord.st).w;\n"
        "\n"
        "  if(display==0)\n"
        "  {\n"
        "    // lambertian lighting + ambient (white light source assumed)\n"
        "    // diffuse dirnl light 0:\n"
        "    float cosineTerm = max(dot(n,l0),0.0);\n"
        "    float warpedTerm = enabled ? (0.6*cosineTerm*warp(cosineTerm,c) + 0.2*warp(1.0,c) ) : (0.6*cosineTerm + 0.2);\n"
        "    fcolour = m*warpedTerm;\n"
        "    // diffuse dirnl light 1:\n"
        "    cosineTerm = max(dot(n,l1),0.0);\n"
        "    warpedTerm = enabled ? (0.6*cosineTerm*warp(cosineTerm,c) ) : (0.6*cosineTerm);\n"
        "    fcolour += m*warpedTerm;\n"
        "    // blend in hidden manipulators\n"
        "    vec4 texel = texture(manipTTexture, texCoord.st);\n"
        "    fcolour = vec4(mix(fcolour.rgb, texel.rgb, texel.a), fcolour.a);\n"
        "  }\n"
        "  else if(display==1)\n"
        "  {\n"
        "    // using lit spheres\n"
        "    if(twoLS) {\n"
        "      fcolour = twoLitSphere(n,w,h,c);\n"
        "    } else {\n"
        "      fcolour = oneLitSphere(n,c);\n"
        "    }\n"
        "  }\n"
        "  else if(display==2)\n"
        "  {\n"
        "    // colored descriptor\n"
        "    fcolour = coloredDescriptor(c,w);\n"
        "  }\n"
        "  else if(display==3)\n"
        "  {\n"
        "    // grey descriptor\n"
        "    fcolour = greyDescriptor(c,w);\n"
        "  }\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("masks.cl",
        "/**\n"
        " * @file\n"
        " *\n"
        " * Utilities for preprocessing terrain type masks.\n"
        " */\n"
        "\n"
        "__constant sampler_t clampSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST;\n"
        "\n"
        "/**\n"
        " * Fill a type constraint mask with allow-any pattern.\n"
        " *\n"
        " * @param[out] out     Image to fill (one workitem per pixel).\n"
        " */\n"
        "__kernel void clearMasks(__write_only image2d_t out)\n"
        "{\n"
        "    int2 coords = (int2) (get_global_id(0), get_global_id(1));\n"
        "    write_imageui(out, coords, (uint4) (0, 0, 0, 0));\n"
        "}\n"
        "\n"
        "/**\n"
        " * Downsample a type constraint mask. One work item is used per element of the\n"
        " * output image. Each output permitted mask is the union of the permitted masks\n"
        " * from a 4x4 neighborhood of the input. The lower corner of this 4x4 block is\n"
        " * at 2 * @a inCoords + @a bias.\n"
        " *\n"
        " * It is not necessary for all addressed pixels to exist: a clamp-to-border\n"
        " * sampler is used.\n"
        " *\n"
        " * @param[out] out     Generated image\n"
        " * @param      in      Input image, at twice the resolution.\n"
        " * @param      bias    Bias used to calculate input coordinates.\n"
        " * @param      bad     Bitfield of types that do not appear in the coarse exemplar\n"
        " */\n"
        "__kernel void downsampleMasks(\n"
        "    __write_only image2d_t out,\n"
        "    __read_only image2d_t in,\n"
        "    int2 bias,\n"
        "    uint bad)\n"
        "{\n"
        "    int2 outCoords = (int2) (get_global_id(0), get_global_id(1));\n"
        "    int2 inCoords = 2 * outCoords + bias;\n"
        "    int2 delta;\n"
        "    uint m = ~0U;\n"
        "    for (delta.y = 0; delta.y < 2; delta.y++)\n"
        "        for (delta.x = 0; delta.x < 2; delta.x++)\n"
        "        {\n"
        "            uint v = read_imageui(in, clampSampler, inCoords + delta).x;\n"
        "            v = (v == 0) ? ~0U : v;\n"
        "            m &= v;\n"
        "        }\n"
        "    m |= bad;\n"
        "    m = (m == ~0U) ? 0 : m;\n"
        "    write_imageui(out, outCoords, (uint4) m);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("synthesis.cl",
        "/**\n"
        " * @file\n"
        " *\n"
        " * Assorted kernels related to texture synthesis.\n"
        " */\n"
        "\n"
        "#ifdef UNIT_TEST\n"
        "# define RANDOM_TABLE_BITS 10\n"
        "# define NUM_MATCHES 2\n"
        "# define MATCH_PARAMETERS __read_only image2d_t match0, __read_only image2d_t match1\n"
        "# define LOAD_MATCHES() \\\n"
        "    do { \\\n"
        "        m[0] = readMatch(match0, coords); \\\n"
        "        m[1] = readMatch(match1, coords); \\\n"
        "    } while (0)\n"
        "# define CORRECT_MAX_WIDTH 8\n"
        "# define CORRECT_MAX_HEIGHT 16\n"
        "#endif\n"
        "\n"
        "#ifndef RANDOM_TABLE_BITS\n"
        "# error \"RANDOM_TABLE_BITS must be defined\"\n"
        "/// Log base 2 of the size of the random table provided to @ref randomOffset\n"
        "# define RANDOM_TABLE_BITS 10\n"
        "#endif\n"
        "#ifndef NUM_MATCHES\n"
        "# error \"NUM_MATCHES must be defined\"\n"
        "#endif\n"
        "#ifndef MATCH_PARAMETERS\n"
        "# error \"MATCH_PARAMETERS must be defined\"\n"
        "#endif\n"
        "#ifndef LOAD_MATCHES\n"
        "# error \"LOAD_MATCHES must be defined\"\n"
        "#endif\n"
        "#if !defined(CORRECT_MAX_WIDTH) || !defined(CORRECT_MAX_HEIGHT)\n"
        "# error \"CORRECT_MAX_WIDTH and CORRECT_MAX_HEIGHT must be defined\"\n"
        "#endif\n"
        "\n"
        "// Uncomment to get warnings about out-of-range accesses\n"
        "// #define DEBUG_RANGE\n"
        "\n"
        "/**\n"
        " * Type used for coordinates referencing the exemplars. The coordinates\n"
        " * index the flattened coordinate system induced by @ref\n"
        " * gen::CLImageMapArray.\n"
        " */\n"
        "typedef float2 coords_t;\n"
        "\n"
        "/// Compacted form of @ref coords_t, used in global memory.\n"
        "typedef float2 coords_io_t;\n"
        "\n"
        "/// Like @ref coords_t, but includes a height offset.\n"
        "typedef struct\n"
        "{\n"
        "    float2 flat;\n"
        "    float offset;\n"
        "} coords_offset_t;\n"
        "\n"
        "/// Compacted form of @ref coords_offset_t, used in global memory.\n"
        "typedef coords_offset_t coords_offset_io_t;\n"
        "\n"
        "typedef float height_t;      ///< A raw height value\n"
        "typedef float4 appearance_t; ///< An appearance-space vector\n"
        "typedef uint mask_t;         ///< A terrain type mask\n"
        "\n"
        "typedef struct\n"
        "{\n"
        "    int pos;\n"
        "    int padding;\n"
        "    float2 xy;\n"
        "} BiasPair;\n"
        "\n"
        "typedef struct\n"
        "{\n"
        "    BiasPair average[4][3];\n"
        "    BiasPair delta[9];\n"
        "} BiasTable;\n"
        "\n"
        "typedef struct\n"
        "{\n"
        "    uint bits;\n"
        "    uint mask;\n"
        "    uint start;\n"
        "} ByTypeInfo;\n"
        "\n"
        "#ifdef SYNTHESIS_STATS\n"
        "typedef struct\n"
        "{\n"
        "    uint total;\n"
        "    uint fallback;\n"
        "    uint trials[NUM_MATCHES + 2];\n"
        "    uint incompatible[NUM_MATCHES + 2];\n"
        "} Counters;\n"
        "#endif\n"
        "\n"
        "/// Number of entries in the @ref taps array\n"
        "#define NUM_TAPS 4\n"
        "\n"
        "__constant sampler_t directSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
        "__constant sampler_t clampSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST;\n"
        "__constant sampler_t filterSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n"
        "\n"
        "/* Prototype all the functions, to suppress warnings from the Apple\n"
        " * implementations about missing prototypes. While static or inline\n"
        " * ought to work, it causes the machine to reboot instead.\n"
        " */\n"
        "int flatten(int2 coords, int stride);\n"
        "coords_t decodeCoords(coords_io_t in);\n"
        "coords_io_t encodeCoords(coords_t in);\n"
        "coords_t biasCoords(coords_t in, float2 bias);\n"
        "coords_offset_t biasCoordsOffset(coords_offset_t in, float2 bias);\n"
        "void writeCoords(__global coords_offset_io_t *data, int2 pos, int stride, coords_offset_t value);\n"
        "height_t readExemplar(__read_only image2d_t exemplar, coords_offset_t pos, float scale);\n"
        "mask_t readMask(__read_only image2d_t masks, coords_t pos);\n"
        "appearance_t readAppearance(__read_only image2d_t appearance, coords_t pos);\n"
        "appearance_t readAppearanceOffset(\n"
        "    __read_only image2d_t appearance, coords_offset_t pos);\n"
        "coords_t readMatch(__read_only image2d_t match, coords_t pos);\n"
        "uint hash(int2 coords, int bits);\n"
        "float2 randomOffset(int2 coords, __constant float2 *randomTable);\n"
        "bool compatibleMasks(mask_t exemplarMask, mask_t targetMask);\n"
        "coords_offset_t upsamplePixel(\n"
        "    int2 q,\n"
        "    float2 offset, coords_offset_t old,\n"
        "    float jitter, __constant float2 *randomTable);\n"
        "appearance_t coordsToAppearanceAveraged(\n"
        "    __global const coords_offset_io_t * restrict coords,\n"
        "    __read_only image2d_t exemplar,\n"
        "    int pos,\n"
        "    __constant BiasPair *biases);\n"
        "float2 evaluateCorrection(\n"
        "#ifdef SYNTHESIS_STATS\n"
        "    __global volatile Counters * restrict counters, int mid,\n"
        "#endif\n"
        "    coords_t m,\n"
        "    appearance_t nhood[NUM_TAPS],\n"
        "    __read_only image2d_t appearance,\n"
        "    __read_only image2d_t masks,\n"
        "    appearance_t appearanceScale2,\n"
        "    mask_t targetMask);\n"
        "float siso(float x, float a, float c, float t, float lambda);\n"
        "\n"
        "#ifdef SYNTHESIS_STATS\n"
        "# define EVALUATE_CORRECTION(counters, mid, m, nhood, appearance, masks, appearanceScale2, targetMask) \\\n"
        "    (evaluateCorrection((counters), (mid), (m), (nhood), (appearance), (masks), (appearanceScale2), (targetMask)))\n"
        "#else\n"
        "# define EVALUATE_CORRECTION(counters, mid, m, nhood, appearance, masks, appearanceScale2, targetMask) \\\n"
        "    (evaluateCorrection((m), (nhood), (appearance), (masks), (appearanceScale2), (targetMask)))\n"
        "#endif\n"
        "\n"
        "/// Convert buffer coordinates into a linear offset\n"
        "int flatten(int2 coords, int stride)\n"
        "{\n"
        "    return coords.y * stride + coords.x;\n"
        "}\n"
        "\n"
        "/// Unpack coordinates from @ref coords_io_t to @ref coords_t\n"
        "coords_t decodeCoords(coords_io_t in)\n"
        "{\n"
        "    return in;\n"
        "}\n"
        "\n"
        "/// Pack coordinates from @ref coords_t to @ref coords_io_t\n"
        "coords_io_t encodeCoords(coords_t in)\n"
        "{\n"
        "    return in;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Subtract @a bias steps from the given coordinates\n"
        " */\n"
        "coords_t biasCoords(coords_t in, float2 bias)\n"
        "{\n"
        "    return in - bias;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Like @ref biasCoords, but applies to a @ref coords_offset_t (the offset is\n"
        " * unaffected).\n"
        " */\n"
        "coords_offset_t biasCoordsOffset(coords_offset_t in, float2 bias)\n"
        "{\n"
        "    in.flat = biasCoords(in.flat, bias);\n"
        "    return in;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Store coordinates in the synthesized map.\n"
        " *\n"
        " * @param data      Coordinate map\n"
        " * @param pos       XY position to write, relative to the start of the map\n"
        " * @param stride    Pixels per row in @a data\n"
        " * @param value     Output value\n"
        " */\n"
        "void writeCoords(__global coords_offset_io_t *data, int2 pos, int stride, coords_offset_t value)\n"
        "{\n"
        "    data[flatten(pos, stride)] = value;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Read a height from the exemplar, with an exemplar coordinate. The offset stored in\n"
        " * @a pos is added to the sampled height.\n"
        " *\n"
        " * @param exemplar     Height map\n"
        " * @param pos          Position to sample\n"
        " * @param scale        Scale factor for height adjustments\n"
        " *\n"
        " * @note If @a pos falls outside the exemplar, the result is undefined.\n"
        " */\n"
        "height_t readExemplar(__read_only image2d_t exemplar, coords_offset_t pos, float scale)\n"
        "{\n"
        "    return read_imagef(exemplar, filterSampler, pos.flat).x + pos.offset * scale;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Read a mask from the exemplar.\n"
        " *\n"
        " * @param masks        Mask map\n"
        " * @param pos          Position to sample\n"
        " *\n"
        " * @note If @a pos falls outside the exemplar, the result is undefined.\n"
        " */\n"
        "mask_t readMask(__read_only image2d_t masks, coords_t pos)\n"
        "{\n"
        "    return read_imageui(masks, directSampler, pos).x;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Read an appearance vector from the appearance map.\n"
        " *\n"
        " * @param appearance   Exemplar appearance map\n"
        " * @param pos          Position to sample\n"
        " *\n"
        " * @note If @a pos falls outside the exemplar, the result is undefined.\n"
        " */\n"
        "appearance_t readAppearance(__read_only image2d_t appearance, coords_t pos)\n"
        "{\n"
        "#if defined(DEBUG_RANGE) && __OPENCL_C_VERSION__ >= 120\n"
        "    if (any(pos < 0.5f))\n"
        "        printf(\"%d: out of range: %v2f\\n\", __LINE__, pos);\n"
        "#endif\n"
        "\n"
        "    return read_imagef(appearance, filterSampler, pos);\n"
        "}\n"
        "\n"
        "/**\n"
        " * Read an appearance vector from the appearance map. The offset stored in\n"
        " * @a pos is added to the height mode.\n"
        " *\n"
        " * @param appearance   Exemplar appearance map\n"
        " * @param pos          Position to sample\n"
        " *\n"
        " * @note If @a pos falls outside the exemplar, the result is undefined.\n"
        " */\n"
        "appearance_t readAppearanceOffset(\n"
        "    __read_only image2d_t appearance, coords_offset_t pos)\n"
        "{\n"
        "    float4 out = readAppearance(appearance, pos.flat);\n"
        "    out.x += pos.offset;\n"
        "    return out;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Read a match from the match table.\n"
        " */\n"
        "coords_t readMatch(__read_only image2d_t match, coords_t pos)\n"
        "{\n"
        "    coords_t ans = read_imagef(match, directSampler, pos).xy;\n"
        "    ans += pos;\n"
        "    return ans;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Takes a coordinate and produces a pseudo-random seed value, in the range\n"
        " * <code>[0, 2<sup>@a bits</sup>)</code>.\n"
        " */\n"
        "uint hash(int2 coords, int bits)\n"
        "{\n"
        "    // Magic value is for Fibonacci hash i.e. an approximation to the Golden ratio\n"
        "    return (uint) (coords.x * 0x9e3779b9 + coords.y * 0x79b90000) >> (32 - bits);\n"
        "}\n"
        "\n"
        "/**\n"
        " * Obtain a random value in [-1, 1]<sup>2</sup>, which depends only on the\n"
        " * input coordinates.\n"
        " *\n"
        " * @param coords          Hash key\n"
        " * @param randomTable     A lookup table of 2<sup>@ref RANDOM_TABLE_BITS</sup> random values in [-1, 1]<sup>2</sup>\n"
        " */\n"
        "float2 randomOffset(int2 coords, __constant float2 *randomTable)\n"
        "{\n"
        "    return randomTable[hash(coords, RANDOM_TABLE_BITS)];\n"
        "}\n"
        "\n"
        "/**\n"
        " * Returns whether a mask value from the exemplar matches the given constraint.\n"
        " */\n"
        "bool compatibleMasks(mask_t exemplarMask, mask_t targetMask)\n"
        "{\n"
        "    return (exemplarMask | targetMask) != ~0U;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Performs upsample and jitter for a single output pixel\n"
        " *\n"
        " * @param q        Location of the output pixel\n"
        " * @param offset   Offset to add to the parent coords\n"
        " * @param old      Parent coordinates, doubled\n"
        " * @param jitter   Maximum jitter distance in pixels\n"
        " * @param randomTable    See @ref randomOffset\n"
        " */\n"
        "coords_offset_t upsamplePixel(\n"
        "    int2 q,\n"
        "    float2 offset, coords_offset_t old,\n"
        "    float jitter, __constant float2 *randomTable)\n"
        "{\n"
        "    coords_offset_t c = old;\n"
        "    c.flat += offset;\n"
        "    c.flat += jitter * randomOffset(q, randomTable);\n"
        "#if defined(DEBUG_RANGE) && __OPENCL_C_VERSION__ >= 120\n"
        "    if (any(c.flat < 1.5f))\n"
        "        printf(\"%d: out of range: %v2f\\n\", __LINE__, c.flat);\n"
        "#endif\n"
        "    return c;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Coordinates are manipulated in the global coordinate space, and only\n"
        " * biased when accessing input and output images (which each provide a window\n"
        " * into this infinite global coordinate space).\n"
        " *\n"
        " * @param      src       Coarse image\n"
        " * @param[out] dest      Fine image\n"
        " * @param      srcStride, destStride Strides for @a src and @a dest\n"
        " * @param      gidBias   Added to global ID, to compensate for OpenCL not allowing negative offsets\n"
        " * @param      srcBase   Global position of origin of @a src\n"
        " * @param      destBase  Global position of origin of @a dest\n"
        " * @param      jitter    Maximum jitter distance in pixels of @a fine\n"
        " * @param      randomTable     Table of random values (see @ref upsamplePixel)\n"
        " *\n"
        " * X positions are offset (prior to jitter) by offset.s0 or offset.s2 (which\n"
        " * are negative and positive respectively), depending on parity.  Y positions\n"
        " * are similarly offset by offset.s1 and offset.s3.\n"
        " *\n"
        " * @todo incorporate @a jitter into @a randomTable?\n"
        " */\n"
        "__kernel void upsampleImage(\n"
        "    const __global coords_offset_io_t * restrict src,\n"
        "    __global coords_offset_io_t * restrict dest,\n"
        "    int srcStride,\n"
        "    int destStride,\n"
        "    int2 gidBias,\n"
        "    int2 srcBase,\n"
        "    int2 destBase,\n"
        "    float jitter,\n"
        "    __constant float2 *randomTable)\n"
        "{\n"
        "    // TODO: compute global ID manually since offset==0 is known\n"
        "    int2 p2d = (int2) (get_global_id(0), get_global_id(1)) + gidBias;\n"
        "    int p = flatten(p2d - srcBase, srcStride);\n"
        "    coords_offset_t old = src[p];\n"
        "    old.flat *= 2.0f;\n"
        "\n"
        "    int2 q2d;\n"
        "    coords_offset_t c;\n"
        "\n"
        "    q2d = (int2) (2 * p2d.x, 2 * p2d.y);\n"
        "    c = upsamplePixel(q2d, (float2) (-0.5f, -0.5f), old, jitter, randomTable);\n"
        "    writeCoords(dest, q2d - destBase, destStride, c);\n"
        "\n"
        "    q2d = (int2) (2 * p2d.x + 1, 2 * p2d.y);\n"
        "    c = upsamplePixel(q2d, (float2) (0.5f, -0.5f), old, jitter, randomTable);\n"
        "    writeCoords(dest, q2d - destBase, destStride, c);\n"
        "\n"
        "    q2d = (int2) (2 * p2d.x + 1, 2 * p2d.y + 1);\n"
        "    c = upsamplePixel(q2d, (float2) (0.5f, 0.5f), old, jitter, randomTable);\n"
        "    writeCoords(dest, q2d - destBase, destStride, c);\n"
        "\n"
        "    q2d = (int2) (2 * p2d.x, 2 * p2d.y + 1);\n"
        "    c = upsamplePixel(q2d, (float2) (-0.5f, 0.5f), old, jitter, randomTable);\n"
        "    writeCoords(dest, q2d - destBase, destStride, c);\n"
        "}\n"
        "\n"
        "/**\n"
        " * Load three appearance samples from the synthesized image and return their mean.\n"
        " * The sample positions are given by the 3 elements of @a biases.\n"
        " *\n"
        " * @param coords        Synthesized exemplar coordinates\n"
        " * @param exemplar      Appearance-space exemplar image\n"
        " * @param pos           Position of one of the samples\n"
        " * @param biases        Table of offsets for the current tap\n"
        " */\n"
        "appearance_t coordsToAppearanceAveraged(\n"
        "    __global const coords_offset_io_t * restrict coords,\n"
        "    __read_only image2d_t exemplar,\n"
        "    int pos,\n"
        "    __constant BiasPair *biases)\n"
        "{\n"
        "    coords_offset_t lc = coords[pos + biases[0].pos];\n"
        "    appearance_t s = readAppearanceOffset(exemplar, lc);\n"
        "\n"
        "    /* TODO: lc could be out of range of the appearance exemplar below.\n"
        "     */\n"
        "    lc = biasCoordsOffset(coords[pos + biases[1].pos], biases[1].xy);\n"
        "    s += readAppearanceOffset(exemplar, lc);\n"
        "\n"
        "    lc = biasCoordsOffset(coords[pos + biases[2].pos], biases[2].xy);\n"
        "    s += readAppearanceOffset(exemplar, lc);\n"
        "\n"
        "    s *= 1.0f / 3.0f;\n"
        "    return s;\n"
        "}\n"
        "\n"
        "/// Relative offsets (in the output space) to where appearance vectors should be sampled\n"
        "__constant float2 taps[NUM_TAPS] =\n"
        "{\n"
        "    (float2) (-1.0f, -1.0f),\n"
        "    (float2) (1.0f, -1.0f),\n"
        "    (float2) (-1.0f, 1.0f),\n"
        "    (float2) (1.0f, 1.0f)\n"
        "};\n"
        "\n"
        "/**\n"
        " * Evaluate the match score for a single correction candidate.\n"
        " *\n"
        " * @param m             Candidate match to evaluate\n"
        " * @param nhood         Current neighborhood\n"
        " * @param appearance    Appearance-space image\n"
        " * @param masks         Type masks corresponding to @a appearance\n"
        " * @param appearanceScale2 Square of scale factors to apply to appearance values\n"
        " * @param targetMask    Type mask specified by the user\n"
        " *\n"
        " * @return The match score and corresponding height adjustment.\n"
        " */\n"
        "float2 evaluateCorrection(\n"
        "#ifdef SYNTHESIS_STATS\n"
        "    __global volatile Counters * restrict counters, int mid,\n"
        "#endif\n"
        "    coords_t m,\n"
        "    appearance_t nhood[NUM_TAPS],\n"
        "    __read_only image2d_t appearance,\n"
        "    __read_only image2d_t masks,\n"
        "    appearance_t appearanceScale2,\n"
        "    mask_t targetMask)\n"
        "{\n"
        "    // TODO: move out of here, so that it is not checked in the fallback path\n"
        "    mask_t mask = readMask(masks, m);\n"
        "#ifdef SYNTHESIS_STATS\n"
        "    atomic_inc(&counters->trials[mid]);\n"
        "#endif\n"
        "    if (!compatibleMasks(mask, targetMask))\n"
        "    {\n"
        "#ifdef SYNTHESIS_STATS\n"
        "        atomic_inc(&counters->incompatible[mid]);\n"
        "#endif\n"
        "        return (float2) (HUGE_VALF, HUGE_VALF);\n"
        "    }\n"
        "\n"
        "    appearance_t delta[NUM_TAPS];\n"
        "    float heightOffset = 0.0f;\n"
        "    for (int j = 0; j < NUM_TAPS; j++)\n"
        "    {\n"
        "        coords_t lc;\n"
        "        lc = m;\n"
        "        lc.xy += taps[j];\n"
        "        delta[j] = nhood[j] - readAppearance(appearance, lc);\n"
        "        heightOffset += delta[j].s0;\n"
        "    }\n"
        "    heightOffset *= 1.0f / NUM_TAPS;\n"
        "\n"
        "    appearance_t sum2 = 0.0f;\n"
        "    for (int j = 0; j < NUM_TAPS; j++)\n"
        "    {\n"
        "        delta[j].s0 -= heightOffset;\n"
        "        sum2 += delta[j] * delta[j];\n"
        "    }\n"
        "\n"
        "    float score = dot(sum2, appearanceScale2);\n"
        "    return (float2) (score, heightOffset);\n"
        "}\n"
        "\n"
        "// Actually returns a siso curve minus x\n"
        "float siso(float x, float a, float c, float t, float lambda)\n"
        "{\n"
        "    if (x < -t)\n"
        "        return (lambda - 1) * x - c;\n"
        "    else if (x > t)\n"
        "        return (lambda - 1) * x + c;\n"
        "    else\n"
        "        return a * x * x * x;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Apply correction step. In this kernel, the image coordinates (p) are simply\n"
        " * relative to the image origin (of the input @em and output image), rather than\n"
        " * the global coordinate system. This is safe because there are no\n"
        " * coordinate-dependent hashes.\n"
        " *\n"
        " * @param appearance    Appearance-space exemplar image at appropriate level of Gaussian stack\n"
        " * @param masks         Exemplar image terrain type masks\n"
        " * @param image         Uncorrected (or partially corrected) image\n"
        " * @param imageStride   Width of @a image\n"
        " * @param heightConstraint Height constraint values. Each is a pair of floats: a\n"
        " *                      target height and a weight for the constraint (a weight\n"
        " *                      of zero indicating no constraint).\n"
        " * @param heightConstraintOffset An offset to be added to image-relative coordinates to obtain coordinates within height constraint image\n"
        " * @param typeConstraint Masks of disallowed terrain types, per pixel\n"
        " * @param typeConstraintOffset An offset to be added to image-relative coordinates to obtain coordinates within type constraint image\n"
        " * @param temporalConstraint Temporal constraint values. Each is a candidate that\n"
        " *                      is weighted by the corresponding element of @a temporalWeight. It may be\n"
        " *                      null.\n"
        " * @param temporalWeight Weights applied to temporal constraints. A weight of 1 has (almost) no\n"
        " *                      effect, while a weight of 0 locks down a region.\n"
        " * @param[out] updateTemporalConstraint Temporal constraint which should receive a\n"
        " *                      copy of the updated synthesis results. It may be null.\n"
        " * @param temporalConstraintStride Width of temporal constraint image\n"
        " * @param temporalConstraintOffset An offset to be added to image-relative coordinates to obtain coordinates within temporal constraint images\n"
        " * @param globalSize    Actual limits for global ID\n"
        " * @param subpassOffset X and Y offsets (either 0 or 1) for the current sub-pass\n"
        " * @param appearanceScale2 Square of scale factors to apply to appearance values\n"
        " * @param kappa         Scale factor to weight cost of the second and later jumps\n"
        " * @param lambda        Slope for linear portion of height adjustment function\n"
        " * @param byType        List of coordinates where one can find each type of terrain\n"
        " * @param byTypeInfo    Metadata necessary for addressing @a byType\n"
        " * @param biasTable     Table of offsets (see @ref BiasTable)\n"
        " *\n"
        " * @note The remaining parameters are <code>__read_only image3d_t\n"
        " * match</code>@a i, which are placed into the @c MATCH_PARAMETERS macro.\n"
        " */\n"
        "__kernel __attribute__((reqd_work_group_size(CORRECT_MAX_WIDTH, CORRECT_MAX_HEIGHT, 1)))\n"
        "void correct(\n"
        "    __read_only image2d_t appearance,\n"
        "    __read_only image2d_t masks,\n"
        "    __global coords_offset_io_t * restrict image, int imageStride,\n"
        "    __read_only image2d_t heightConstraint, int2 heightConstraintOffset,\n"
        "    __read_only image2d_t typeConstraint, int2 typeConstraintOffset,\n"
        "\n"
        "    __global const coords_io_t *temporalConstraint,\n"
        "    __global const float * restrict temporalWeight,\n"
        "    __global coords_io_t *updateTemporalConstraint,\n"
        "    int temporalConstraintStride,\n"
        "    int temporalConstraintOffset,\n"
        "\n"
        "    int2 globalSize,\n"
        "    int2 subpassOffset,\n"
        "    appearance_t appearanceScale2,\n"
        "    float kappa,\n"
        "    float lambda,\n"
        "\n"
        "    __global const coords_io_t * restrict byType,\n"
        "    __constant ByTypeInfo *byTypeInfo,\n"
        "    __constant BiasTable *biasTable,\n"
        "#ifdef SYNTHESIS_STATS\n"
        "    __global volatile Counters * restrict counters,\n"
        "#endif\n"
        "    MATCH_PARAMETERS)\n"
        "{\n"
        "    int2 gid = (int2) (get_global_id(0), get_global_id(1));\n"
        "    if (any(gid >= globalSize))\n"
        "        return;\n"
        "\n"
        "    int lid = get_local_id(1) * get_local_size(0) + get_local_id(0);\n"
        "    int2 p2d = gid * 2 + subpassOffset;\n"
        "    int p = flatten(p2d, imageStride);\n"
        "    float bestScore = HUGE_VALF;\n"
        "    coords_offset_t best;\n"
        "\n"
        "    appearance_t nhood[NUM_TAPS];\n"
        "    for (int i = 0; i < NUM_TAPS; i++)\n"
        "        nhood[i] = coordsToAppearanceAveraged(\n"
        "            image, appearance, p, &biasTable->average[i][0]);\n"
        "\n"
        "    mask_t targetMask = read_imageui(typeConstraint, clampSampler, p2d + typeConstraintOffset).x;\n"
        "    int temporalIdx = flatten(p2d, temporalConstraintStride) + temporalConstraintOffset;\n"
        "\n"
        "    if (temporalConstraint != 0)\n"
        "    {\n"
        "        coords_t coords = decodeCoords(temporalConstraint[temporalIdx]);\n"
        "        float2 eval = EVALUATE_CORRECTION(\n"
        "            counters, NUM_MATCHES, coords, nhood, appearance, masks, appearanceScale2, targetMask);\n"
        "        bestScore = eval.s0 * temporalWeight[temporalIdx];\n"
        "        best.flat = coords;\n"
        "        best.offset = eval.s1;\n"
        "    }\n"
        "\n"
        "    __local coords_t cand[9][CORRECT_MAX_WIDTH * CORRECT_MAX_HEIGHT];\n"
        "    int numCand = 0;\n"
        "    for (int di = 0; di < 9; di++)\n"
        "    {\n"
        "        coords_t coords = decodeCoords(image[p + biasTable->delta[di].pos].flat);\n"
        "        coords = biasCoords(coords, biasTable->delta[di].xy);\n"
        "        bool skip = false;\n"
        "        for (int j = 0; j < numCand && !skip; j++)\n"
        "            if (all(coords == cand[j][lid]))\n"
        "                skip = true;\n"
        "        if (!skip)\n"
        "            cand[numCand++][lid] = coords;\n"
        "    }\n"
        "\n"
        "    for (int di = 0; di < numCand; di++)\n"
        "    {\n"
        "        coords_t coords = cand[di][lid];\n"
        "\n"
        "        coords_t m[NUM_MATCHES];\n"
        "        LOAD_MATCHES();\n"
        "        for (int i = 0; i < NUM_MATCHES; i++)\n"
        "        {\n"
        "            float2 eval = EVALUATE_CORRECTION(\n"
        "                counters, i, m[i], nhood, appearance, masks, appearanceScale2, targetMask);\n"
        "            if (i > 0)\n"
        "                eval.s0 *= kappa;\n"
        "            if (eval.s0 < bestScore)\n"
        "            {\n"
        "                bestScore = eval.s0;\n"
        "                best.flat = m[i];\n"
        "                best.offset = eval.s1;\n"
        "            }\n"
        "        }\n"
        "    }\n"
        "\n"
        "    if (bestScore == HUGE_VALF)\n"
        "    {\n"
        "        /* No match found that satisfies the mask constraint.\n"
        "         * Pick some random ones instead.\n"
        "         */\n"
        "#ifdef SYNTHESIS_STATS\n"
        "        atomic_inc(&counters->fallback);\n"
        "#endif\n"
        "        mask_t validTargets = ~targetMask;\n"
        "        while (validTargets != 0)\n"
        "        {\n"
        "            int t = 31 - clz(validTargets);\n"
        "            validTargets ^= 1U << t;\n"
        "            ByTypeInfo info = byTypeInfo[t];\n"
        "            if (info.bits > 0)\n"
        "            {\n"
        "                uint pos = hash(p2d, info.bits);\n"
        "                for (int di = 0; di < 9; di++)\n"
        "                {\n"
        "                    coords_t coords = decodeCoords(byType[info.start + pos]);\n"
        "                    pos = (pos + lid + 1) & info.mask;\n"
        "\n"
        "                    float2 eval = EVALUATE_CORRECTION(\n"
        "                        counters, NUM_MATCHES + 1, coords, nhood, appearance, masks, appearanceScale2, targetMask);\n"
        "                    if (eval.s0 < bestScore)\n"
        "                    {\n"
        "                        bestScore = eval.s0;\n"
        "                        best.flat = coords;\n"
        "                        best.offset = eval.s1;\n"
        "                    }\n"
        "                }\n"
        "            }\n"
        "        }\n"
        "    }\n"
        "\n"
        "    float4 hc = read_imagef(heightConstraint, directSampler, p2d + heightConstraintOffset);\n"
        "    float curHeight = readAppearanceOffset(appearance, best).s0;\n"
        "    float delta = curHeight - hc.s0;\n"
        "    float newDelta = siso(delta, hc.s1, hc.s2, hc.s3, lambda);\n"
        "#ifdef AMD_GPU_BUG_WORKAROUND\n"
        "    // Without this, the AMD Catalyst drivers (14.4) seems to miscompile the code\n"
        "    image[p].flat = best.flat;\n"
        "    image[p].offset = best.offset + newDelta;\n"
        "#else\n"
        "    best.offset += newDelta;\n"
        "    image[p] = best;\n"
        "#endif\n"
        "    if (updateTemporalConstraint != 0)\n"
        "    {\n"
        "        updateTemporalConstraint[temporalIdx] = encodeCoords(best.flat);\n"
        "    }\n"
        "\n"
        "#ifdef SYNTHESIS_STATS\n"
        "    atomic_inc(&counters->total);\n"
        "#endif\n"
        "}\n"
        "\n"
        "/**\n"
        " * Fill a buffer of @c coords_offset_io_t with a fixed value.\n"
        " */\n"
        "__kernel void initCoords(__global coords_offset_io_t *image, coords_io_t flat)\n"
        "{\n"
        "    size_t gid = get_global_id(0);\n"
        "    image[gid].flat = flat;\n"
        "    image[gid].offset = 0.0f;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Fill a buffer of floats with a fixed value.\n"
        " */\n"
        "__kernel void fillWeights(__global float *buffer, float value)\n"
        "{\n"
        "    size_t gid = get_global_id(0);\n"
        "    buffer[gid] = value;\n"
        "}\n"
        "\n"
        "/**\n"
        " * Use one image of coordinates to sample another image. The coordinates are\n"
        " * of type @ref coords_offset_io_t, while the exemplar and output uses @ref height_t.\n"
        " * The global work item IDs reference the input image, and they are then added to\n"
        " * outOffset to obtain output coordinates.\n"
        " *\n"
        " * @param coords             Image with coordinates\n"
        " * @param exemplar           Image addressed by the coordinates\n"
        " * @param[out] out           Output image\n"
        " * @param outOffset          Difference between input and output coordinates\n"
        " * @param coordsStride       Width of @a coords\n"
        " * @param heightScale        Scale factor for height offsets\n"
        " *\n"
        " * @pre The coordinates are in range.\n"
        " */\n"
        "__kernel void sampleImage(\n"
        "    const __global coords_offset_io_t * restrict coords,\n"
        "    __read_only image2d_t exemplar,\n"
        "    __write_only image2d_t out,\n"
        "    int2 outOffset,\n"
        "    int coordsStride,\n"
        "    float heightScale)\n"
        "{\n"
        "    int2 p2d = (int2) (get_global_id(0), get_global_id(1));\n"
        "    int p = flatten(p2d, coordsStride);\n"
        "\n"
        "    coords_offset_t c = coords[p];\n"
        "    height_t pixel = readExemplar(exemplar, c, heightScale);\n"
        "    int2 outPos = p2d + outOffset;\n"
        "    write_imagef(out, outPos, (float4) pixel);\n"
        "}\n"
        "\n"
        "/**\n"
        " * An analogue of @ref sampleImage that samples an image of type masks rather\n"
        " * than an image of heights.\n"
        " *\n"
        " * @param coords             Image with coordinates\n"
        " * @param masks              Image addressed by the coordinates\n"
        " * @param[out] out           Output image\n"
        " * @param outOffset          Difference between input and output coordinates\n"
        " * @param coordsStride       Width of @a coords\n"
        " */\n"
        "__kernel void sampleMask(\n"
        "    const __global coords_offset_io_t * restrict coords,\n"
        "    __read_only image2d_t masks,\n"
        "    __write_only image2d_t out,\n"
        "    int2 outOffset,\n"
        "    int coordsStride)\n"
        "{\n"
        "    int2 p2d = (int2) (get_global_id(0), get_global_id(1));\n"
        "    int p = flatten(p2d, coordsStride);\n"
        "\n"
        "    coords_offset_t c = coords[p];\n"
        "    mask_t pixel = read_imageui(masks, clampSampler, c.flat).x;\n"
        "    int2 outPos = p2d + outOffset;\n"
        "    write_imageui(out, outPos, (uint4) pixel);\n"
        "}\n"
    ),
    std::pair<uts::string, uts::string>("texmark.cl",
        "__constant sampler_t directSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
        "\n"
        "inline float sample(__read_only image2d_t image, int2 pos)\n"
        "{\n"
        "    float4 v = read_imagef(image, directSampler, pos);\n"
        "    return v.x + v.y + v.z + v.w;\n"
        "}\n"
        "\n"
        "__kernel void benchmark2d(__read_only image2d_t image, __global uint *out)\n"
        "{\n"
        "    int2 gid = (int2) (get_global_id(0), get_global_id(1)) ADDR_MODIFIER;\n"
        "    float sum = sample(image, gid);\n"
        "    sum += sample(image, gid + (int2) (5, 5));\n"
        "    sum += sample(image, gid + (int2) (10, 10));\n"
        "    sum += sample(image, gid + (int2) (-5, 5));\n"
        "    sum += sample(image, gid + (int2) (5, -5));\n"
        "    sum += sample(image, gid + (int2) (0, 20));\n"
        "    sum += sample(image, gid + (int2) (0, -20));\n"
        "    sum += sample(image, gid + (int2) (-20, 0));\n"
        "    sum += sample(image, gid + (int2) (20, 0));\n"
        "\n"
        "    volatile float sink = sum;\n"
        "}\n"
    ),

};

const uts::unordered_map<uts::string, uts::string> &getSourceMap()
{
    return g_sources;
}

const uts::string &getSource(const uts::string &filename)
{
    auto pos = g_sources.find(filename);
    if (pos == g_sources.end())
        throw std::invalid_argument("Source " + filename + " not found");
    return pos->second;
}

